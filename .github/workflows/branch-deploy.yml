name: branch-deploy

on:
  issue_comment:
    types: [ created ]

# Custom configration to define branch-deploy commands
env:
  WORKING_DIR: "terraform/"
  DEPLOY_COMMAND: ".deploy"
  MAIN_BRANCH: "main"

jobs:
  # The 'params' job makes certain env vars available to parts of the GitHub Actions workflow that generally doesn't support env vars
  # https://github.com/actions/runner/issues/480#issuecomment-1055373623
  params:
    name: Setup env
    runs-on: ubuntu-latest
    outputs:
        params: ${{ steps.env-vars.outputs.params }}
    steps:
      - name: install jq
        run: pip install jq
      - id: env-vars
        name: Output environment variables
        run: echo "::set-output name=params::$(echo $(jq -n 'env'))"

  prechecks:
    needs: [ params ]
    if: github.event.issue.pull_request != null && (startsWith(github.event.comment.body, ${{ fromJson(needs.params.outputs.params).DEPLOY_COMMAND }}))
    outputs:
      ref: ${{steps.prechecks.outputs.ref}}
      eyes: ${{steps.prechecks.outputs.eyes}}
      sha: ${{steps.prechecks.outputs.sha}}
    runs-on: ubuntu-latest

    steps:
      - name: Check permissions, PR ref, and CI
        id: prechecks
        env:
          comment: ${{ github.event.comment.body }}
          PR_NUMBER: ${{ github.event.issue.number}}
        uses: actions/github-script@f05a81df23035049204b043b50c3322045ce7eb3 # pin@v3
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            const comment = process.env.comment;
            const reactionRes = await github.reactions.createForIssueComment({
              ...context.repo,
              comment_id: ${{github.event.comment.id}},
              content: 'eyes'
            })
            core.setOutput('eyes', reactionRes.data.id)
            const permissionRes = await github.repos.getCollaboratorPermissionLevel(
              {
                ...context.repo,
                username: context.actor
              }
            )
            if (permissionRes.status !== 200) {
              message = 'Permission check returns non-200 status: ${permissionRes.status}'
              core.setOutput('error', message)
              throw new Error(message)
            }
            const actorPermission = permissionRes.data.permission
            if (!['admin', 'write'].includes(actorPermission)) {
                message = '👋  __' + context.actor + '__, seems as if you have not admin/write permission to branch-deploy this PR, permissions: ${actorPermission}'
                core.setOutput('error', message)
                throw new Error(message)
            }
            pr = await github.pulls.get(
              {
                ...context.repo,
                pull_number: context.issue.number
              }
            )
            if (pr.status !== 200) {
              message = 'Could not retrieve PR info: ${permissionRes.status}'
              core.setOutput('error', message)
              throw new Error(message)
            }

            // Check to ensure PR CI checks and merge status are passing
            const query = `query($owner:String!, $name:String!, $number:Int!) {
                    repository(owner:$owner, name:$name) {
                        pullRequest(number:$number) {
                            reviewDecision
                            mergeStateStatus
                            commits(last: 1) {
                                nodes {
                                    commit {
                                        statusCheckRollup {
                                            state
                                        }
                                    }
                                }
                            }
                        }
                    }
                }`;
              const variables = {
                owner: context.repo.owner,
                name: context.repo.repo,
                number: parseInt(process.env.PR_NUMBER),
                headers: {
                  Accept: "application/vnd.github.merge-info-preview+json"
                }
              }

              // Make the GraphQL query
              const result = await github.graphql(query, variables)

              // Grab the reviewDecision and commitStatus values from the GraphQL result
              const reviewDecision = result.repository.pullRequest.reviewDecision;
              const commitStatus = result.repository.pullRequest.commits.nodes[0].commit.statusCheckRollup.state;

              // If everything is OK, print a nice message
              if (reviewDecision === "APPROVED" && commitStatus === "SUCCESS") {
                  const message = "✔️ Merge is clean and all checks passed - OK";
                  console.log(message);
              // If there are any issues blocking deployment, throw an error and save the error message as an output
              } else {
                  const message = `### ⚠️ Cannot proceed with deployment\n\n- reviewDecision: \`${reviewDecision}\`\n- commitStatus: \`${commitStatus}\`\n\n> This is usually caused by missing PR approvals or CI checks failing`;
                  core.setOutput('error', message);
                  throw new Error(message);
              }

            // check if comment starts with the env.DEPLOY_COMMAND variable and is followed by the 'main' branch
            // This is used to roll back a deployment to the 'main' branch
            var ref
            const regexCommandWithMain = /^\.deploy\s*(main)$/
            if (regexCommandWithMain.test(comment)) {
              console.log(`${process.env.DEPLOY_COMMAND} command used with 'main' branch - setting REF to ${process.env.DEPLOY_COMMAND}`)
              ref = process.env.MAIN_BRANCH
            } else {
              ref = pr.data.head.ref
            }

            core.setOutput('ref', ref)
            core.setOutput('sha', pr.data.head.sha)

      - name: Pre-Check-Failed
        id: precheck-failed
        if: failure()
        uses: actions/github-script@f05a81df23035049204b043b50c3322045ce7eb3 # pin@v3
        env:
          message: ${{steps.prechecks.outputs.error}}
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            const log_url = `${process.env.GITHUB_SERVER_URL}/${context.repo.owner}/${context.repo.repo}/actions/runs/${process.env.GITHUB_RUN_ID}`
            const { message } = process.env;
            // check if message is null or empty
            if (!message || message.length === 0) {
              message = 'Unknown error, [check logs](' + log_url + ') for more details.'
            }
            github.issues.createComment({
              ...context.repo,
              issue_number: context.issue.number,
              body: message
            })
            await github.reactions.createForIssueComment({
              ...context.repo,
              comment_id: ${{github.event.comment.id}},
              content: '-1'
            })
            await github.reactions.deleteForIssueComment({
              ...context.repo,
              comment_id: ${{github.event.comment.id}},
              reaction_id: ${{steps.prechecks.outputs.eyes}}
            })

  branch-deploy:
    name: "branch deploy"
    if: startsWith(github.event.comment.body, ${{ fromJson(needs.params.outputs.params).DEPLOY_COMMAND }})
    needs: [ prechecks, params ]
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ${{ env.WORKING_DIR }}

    steps:

      - name: create deployment
        id: create_deployment
        uses: octokit/request-action@v2.x
        with:
          route: POST /repos/:repository/deployments
          repository: ${{ github.repository }}
          ref: ${{ needs.prechecks.outputs.ref }}
          environment: production
          auto_merge: false
        env:
          GITHUB_TOKEN: "${{ secrets.GITHUB_TOKEN }}"

      - name: set deployment status to in progress
        id: start_deployment
        uses: octokit/request-action@v2.x
        with:
          route: POST /repos/:repository/deployments/:deployment/statuses
          repository: ${{ github.repository }}
          deployment: ${{ fromJson(steps.create_deployment.outputs.data).id }}
          environment: production
          log_url: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          state: in_progress
          mediaType: '{"previews": ["flash", "ant-man"]}'
        env:
          GITHUB_TOKEN: "${{ secrets.GITHUB_TOKEN }}"

      - name: Validating command
        id: validate_params
        env:
          REF: ${{ needs.prechecks.outputs.ref }}
          comment: ${{ github.event.comment.body }}
        uses: actions/github-script@f05a81df23035049204b043b50c3322045ce7eb3 # pin@v3
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const comment = process.env.comment;
            var ref = process.env.REF;
            // check if comment starts with the env.DEPLOY_COMMAND variable and is only followed by whitespaces
            const regexCommandWithoutParameters = /^\.deploy\s*$/

            // check if comment starts with the env.DEPLOY_COMMAND variable and is followed by the 'main' branch
            // This is used to roll back a deployment to the 'main' branch
            const regexCommandWithMain = /^\.deploy\s*(main)$/

            if (regexCommandWithoutParameters.test(comment)) {
              console.log(`${process.env.DEPLOY_COMMAND} command used on current branch - OK`)
              BRANCH_NAME = ref
            } else if (regexCommandWithMain.test(comment)) {
              console.log(`${process.env.DEPLOY_COMMAND} command used with 'main' branch - OK`)
              BRANCH_NAME = process.env.MAIN_BRANCH
              ref = BRANCH_NAME
            }
            else {
              message = `Invalid command, please use \`${process.env.DEPLOY_COMMAND}\` or \`${process.env.DEPLOY_COMMAND} ${process.env.MAIN_BRANCH}\`.`
              core.setOutput('error', message)
              await github.issues.createComment({
                ...context.repo,
                issue_number: context.issue.number,
                body: message
              })
              throw new Error(message)
            }

            core.info("branch name: " + BRANCH_NAME)
            core.setOutput('BRANCH_NAME',  BRANCH_NAME)

            const log_url = `${process.env.GITHUB_SERVER_URL}/${context.repo.owner}/${context.repo.repo}/actions/runs/${process.env.GITHUB_RUN_ID}`

            const commentBody = `\
            🚀 __${context.actor}__, starting a branch deployment 

            - Branch: __${BRANCH_NAME}__
            - REF: __${ref}__

            You can watch the progress [here](${log_url})
            `;

            await github.issues.createComment({
              ...context.repo,
              issue_number: context.issue.number,
              body: commentBody
            })

      - name: Checkout
        uses: actions/checkout@ec3a7ce113134d7a93b817d10a8272cb61118579 # pin@v2
        with:
          ref: ${{ needs.prechecks.outputs.ref }}

      - uses: hashicorp/setup-terraform@3d8debd658c92063839bc97da5c2427100420dec # pin@v1
        with:
          terraform_version: 1.1.7
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

      - name: Terraform init
        run: terraform init

      - name: Terraform apply
        env:
          TF_VAR_CLOUDFLARE_TOKEN: ${{ secrets.CLOUDFLARE_TOKEN }}
        id: apply
        run: terraform apply -no-color -auto-approve
        continue-on-error: true

      # Post comment on PR with development plan info
      - uses: actions/github-script@5d03ada4b0a753e9460b312e61cc4f8fdeacf163 # pin@0.9.0
        env:
          APPLY: "terraform ${{ steps.apply.outputs.stdout }}"
          REF: ${{ needs.prechecks.outputs.ref }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const output = `### Deployment Results - Production 🪐
            - Deployment 🚀: \`${{ steps.apply.outcome }}\`
            - Branch: \`${process.env.REF}\`

            <details><summary>Show Apply</summary>

            \`\`\`${process.env.APPLY}\`\`\`

            </details>

            Please wait at least 5 minutes after a deployment to validate your changes before merging

            > Pusher: @${{ github.actor }}, Action: \`${{ github.event_name }}\`, Working Directory: \`terraform/\`, Workflow: \`${{ github.workflow }}\``;

            github.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })

      - name: set deployment status to success
        id: successful_deployment
        uses: octokit/request-action@v2.x
        with:
          route: POST /repos/:repository/deployments/:deployment/statuses
          repository: ${{ github.repository }}
          deployment: ${{ fromJson(steps.create_deployment.outputs.data).id }}
          environment: production
          log_url: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          mediaType: '{"previews": ["ant-man"]}'
          state: success
        env:
          GITHUB_TOKEN: "${{ secrets.GITHUB_TOKEN }}"

      - name: Check Terraform output
        if: steps.apply.outcome == 'failure'
        run: exit 1

      - name: set deployment status to failure
        id: failed_deployment
        uses: octokit/request-action@v2.x
        if: failure()
        with:
          route: POST /repos/:repository/deployments/:deployment/statuses
          repository: ${{ github.repository }}
          deployment: ${{ fromJson(steps.create_deployment.outputs.data).id }}
          environment: production
          log_url: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          mediaType: '{"previews": ["ant-man"]}'
          state: failure
        env:
          GITHUB_TOKEN: "${{ secrets.GITHUB_TOKEN }}"
